"""
Generates Obsidian notes from a conversation.
"""
from typing import List, Dict, Any
from .conversation import Conversation
from .exchange import Exchange
from .message import Message

# Generate Obsidian notes from a conversation using jinja template from templates/article.md.jinja
import re
import os
from pathlib import Path
from jinja2 import Environment, FileSystemLoader, select_autoescape
from jinja2 import Template

import frontmatter
from yaml.parser import ParserError
from yaml.scanner import ScannerError


from loguru import logger

def sanitize_filename(title: str, max_length: int = 200) -> str:
    """
    Sanitize a title to be safe for use as a filename.
    
    Args:
        title: The title to sanitize
        max_length: Maximum length of the resulting filename
        
    Returns:
        A sanitized filename string
    """
    if not title:
        return
    # Replace problematic characters with underscores
    sanitized = re.sub(r'[<>:"/\\|?*\[\]]', '', title)
    if sanitized.lower().startswith('the '):
        sanitized = sanitized[4:]  # Remove 'the ' prefix if present
    # Truncate to max length
    return sanitized[:max_length].lower()


def extract_title(exchange: Exchange) -> str:
    title = exchange.annotations.get('title')
    if not title:
        title = exchange.annotations.get('proposed_title')
    if not title:
        # If no title is set, use the first user message as the title
        user_messages = exchange.get_user_messages()
        if user_messages:
            title = user_messages[0].content.split('\n')[0]
    if not title:
        # If still no title, use a default
        title = f"_untitled_{exchange.exchange_id}"
    return sanitize_filename(title)

def load_template(template_name: str) -> Template:
    """Load a Jinja template from the templates directory."""
    templates_dir = Path(__file__).parent.parent / 'templates'
    env = Environment(
        loader=FileSystemLoader(templates_dir),
        autoescape=select_autoescape(['html', 'xml'])
    )
    return env.get_template(template_name)

def make_metadata(page) -> Dict[str, object]:
    """
    Build a dict that python-frontmatter will turn into YAML.
    """
    return {
        "title": extract_title(page),
        "date": page.first_message_time,
        "tags": [
            "autogenerated",
            f"source__{page.annotations['source']}",
            f"conversation_id__{page.conversation_id}",
            *(f"msg_{mid}" for mid in page.get_message_ids()),
        ],
    }


# before generating the notes, we need to infer some attributes, specifically
# - the title for the preceding note
# - the date of the conversation
# - the title of the proceding note
# notes will generally correspond to a single exchange, so we will generate one note per exchange
# thte title will be associated as an annotation on the exchange
# teh date is an attribute on the exchange object, or the first message in the exchange
# output filename will be the title of the exchange, with spaces replaced by underscores and .md extension
def generate_notes(
        conversation: Conversation,
        template_name: str = 'article_body.md.jinja',
        output_dir: str = 'data/staging'
) -> List[str]:
    """Generate Obsidian notes from a conversation."""
    template = load_template(template_name)
    notes = []

    # need to infer the previous and next note titles before we can generate the notes
    # this is done by iterating through the exchanges and using the annotations
    # we will use the first message's created_date as the date of the exchange
    # and the title from the exchange annotations, or a default title if not present    
    # START BY ASSIGNING DEFAULT TITLES AND FILENAMES SO WE CAN REFER TO THEM WHEN WE NEED THE PREVIOUS AND NEXT TITLES
    for exchange in conversation.exchanges:
        date = exchange.messages[0].created_date if exchange.messages else None
        #title = exchange.annotations.get('title', f'Exchange {exchange.exchange_id}')
    
        title = extract_title(exchange)
                
        #output_filename = f"{title.replace(' ', '_')}.md"
        # need to actually sanitize the title to make it a valid filename
        #output_filename = f"{title.replace(' ', '_').replace('/', '_').replace('\\', '_').replace(':', '_')[:200]}.md"
        output_filename = sanitize_filename(title) + '.md'
        #logger.info(f"output_filename: {output_filename}")
        exchange.annotations['output_filename'] = output_filename
        exchange.annotations['date'] = date
        exchange.annotations['title'] = title
        notes.append((exchange, output_filename))       

    # NOW ASSOCIATE PREVIOUS AND NEXT TITLES
    for i, (exchange, output_filename) in enumerate(notes):
        # Set previous title if not the first exchange
        if i > 0:
            previous_exchange = notes[i - 1][0]
            exchange.annotations['previous_title'] = previous_exchange.annotations['title']
            exchange.annotations['previous_filename'] = previous_exchange.annotations['output_filename']
        else:
            exchange.annotations['previous_title'] = None
            exchange.annotations['previous_filename'] = None
        
        # Set next title if not the last exchange
        if i < len(notes) - 1:
            next_exchange = notes[i + 1][0]
            exchange.annotations['next_title'] = next_exchange.annotations['title']
            exchange.annotations['next_filename'] = next_exchange.annotations['output_filename']
        else:
            exchange.annotations['next_title'] = None
            exchange.annotations['next_filename'] = None

    # NOW GENERATE THE NOTES
    # in retrospect, we should infer initial title, frontmatter, and content,
    # then we can update wikilinks in notes as needed before writing to file
    articles = {}
    for exchange, output_filename in notes: 
        content = template.render(page=exchange)
        metadata = make_metadata(exchange)
        # try:
        #     metadata, content = frontmatter.parse(content)
        # except (ParserError, ScannerError) as e:
        #     print(f"Error parsing frontmatter for {output_filename}: {e}")
        #     print(content)
        #     raise
        #title = exchange.annotations.get('title')
        title = metadata['title']
        articles[title] = {"content": content, "metadata": metadata, "output_filename": output_filename}

    # upgrade titles that appear in content to wikilinks
    for title, article in list(articles.items()):
        content = article['content']
        # replace other titles with wikilinks (if not already a wikilink) 
        for other_title in articles.keys():
            if other_title != title:
                if not re.search(r'\[\[' + re.escape(other_title) + r'\]\]', content):
                    # Replace only if not already a wikilink
                    # Use word boundary to avoid partial matches
                    content = re.sub(rf'\b{re.escape(other_title)}\b', f'[[{other_title}]]', content)
                    articles[title]['content'] = content

    # Ensure output directory exists
    output_path = Path(output_dir)
    output_path.mkdir(parents=True, exist_ok=True)

    # ok, now we can write the articles to files
    for title, article in articles.items():
        content = article['content']
        metadata = article['metadata']
        output_filename = article['output_filename']

        post = frontmatter.Post(content, **metadata)        
        output_filepath = output_path / output_filename
        with open(output_filepath, 'a') as f:
            #frontmatter.dump(post, f)
            f.write(frontmatter.dumps(post))